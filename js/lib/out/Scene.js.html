<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Scene.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Scene.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { Vector } from './Vector.js'
import { Size } from './Size.js'

/**
 * @author vincent jeanvoine
 * @mail hypnolog@yahoo.fr
 * 
 * @version 0.0.1
 * 
 * @classdesc contient et gére la colection d'objets a afficher sur le canvas
 */

export class Scene{
    /**
     * @param  {HTMLCanvasElement} canvas=document.createElement("canvas") - canavas qui affiche le jeux
     * @param  {Number} width=undefined - largeur du canvas
     * @param  {Number} height=undefined - hauteur du canvas
     * @param  {HTMLElement} elt=document.body - élément parent du canvas
     * @description constructor: crée une nouvelle scene
     */
    constructor(canvas = document.createElement("canvas"), elt = document.body){
        this.canvas = canvas

        this.context = this.canvas.getContext('2d')
        
        elt.insertBefore(this.canvas, elt.childNodes[0])

        this.components = {}

        this.zorder = []

        this.timestamp = 0

        this.run()
    }

    set size(val){
        if(val.constructor.name != 'Size')
            throw new Error('"Scene.size" doit être un objet de la class "Size"')

        this.canvas.width = val.width
        this.canvas.height = val.height
    }

    get size(){
        return new Size(this.canvas.width, this.canvas.height)
    }

    get center(){
        return new Vector(this.size.width / 2, this.size.height / 2)
    }


    /* géstion de la lecture des fram */

    /**
     * @description nétoye le canevas (éfface son contenu)
     * @method
     */
    clear(){
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
    }

    /**
     * @param {Number} timestamp - temps à partir duquel l'annimation du canvas a commencer
     * @description met le canevas a jour (avance d'une frame)
     * @method
     */
    update(timestamp){
        this.timestamp = timestamp
        this.clear()

        //for(let key in this.components){
        for(let key of this.zorder){
            this.components[key].update()
        }
        
        this.run()
    }

    /**
     * @description démare la lecture de l'annimation du canvas
     * @method
     */
    run(){
        this.raf = window.requestAnimationFrame((timestamp) => {this.update(timestamp)})
    }

    /**
     * @description arrete la lecture de l'annimation du canvas
     */
    pause(){
        window.cancelAnimationFrame(this.raf)
        this.timestamp = 0
    }


    /* gestion des objets */

    /**
     * @param {Component} component - objet a ajouter a la scene
     * @returns {Scene} retourn la scene "this" pour le chainage
     * @description ajout un objet a la scène si un objet de même nom n'existe pas
     * @method
     */
    addComponent(component){
        if(this.hasComponent(component.name))
            return this
        
        return this.setComponent(component)
    }

    /**
     * @param {Component} component - objet a ajouter/éditer
     * @returns {Scene} retourn la scene "this" pour le chainage
     * @description ajout ou modifi (écrase) un objet de la scène
     * @method
     */
    setComponent(component){
        this.zorder.push(component.name)
        this.components[component.name] = component
        return this
    }

    /**
     * @param {String} name - nom de l'objet a retourner
     * @returns {Component} component ou null si il n'exist pas
     * @description retour l'objet "name" de la scène si il existe ou null si non
     * @method
     */
    getComponent(name){
        if(! this.hasComponent(name))
            return null
        
        return this.components[name]
    }

    /**
     * @description retir et détruis touts les objets de la scène
     * @returns {Scene} retourn la scene "this" pour le chainage
     * @method
     */
    clearComponents(){
        for(let name in this.components){
            this.deleteComponent(name)
        }
        return this
    }

    /**
     * @param {String} name - nom de l'objet a détruire
     * @returns {Scene} retourn la scene "this" pour le chainage
     * @description retir et détruis l'objet "name" de la scène si il existe
     * @method
     */
    deleteComponent(name){
        if(! this.hasComponent(name))
            return this
        
        this.zorder.splice(this.zorder.indexOf(name), 1)
        this.components[name] = undefined
        delete this.components[name]
        return this
    }

    /**
     * @param {String} name - nom de l'objet
     * @returns {Boolean}
     * @description verifi si un objet existe
     * @method
     */
    hasComponent(name){
        return name in this.components
    }

    /**
     * @param {String} name - nom de l'objet
     * @returns {Scene} retourn la scene "this" pour le chainage
     * @description l'objet sera déssiné au dessu des autre
     * @method
     */
    goToTop(name){
        if(this.zorder.indexOf(name)  &lt; 0)
            return this
        
        this.zorder.splice(this.zorder.indexOf(name), 1)
        this.zorder.push(name)
        return this
    }

    /**
     * @param {String} name - nom de l'objet
     * @returns {Scene} retourn la scene "this" pour le chainage
     * @description l'objet sera déssiné en dessou des autre
     * @method
     */
    goToBottom(name){
        if(this.zorder.indexOf(name) &lt; 0)
            return this
        
        this.zorder.splice(this.zorder.indexOf(name), 1)
        this.zorder.unshift(name)
        return this
    }

    /**
     * @param {String} name - nom de l'objet
     * @returns {Scene} retourn la scene "this" pour le chainage
     * @description l'objet sera remonté d'un niveau dans l'ordre dans le quel ils sont déssiné
     * @method
     */
    goUp(name){
        let index = this.zorder.indexOf(name)
        if(index  &lt; 0 || index == this.zorder.length - 1)
            return this
        
        let next = this.zorder[index + 1]
        this.zorder[index + 1] = name
        this.zorder[index] = next
        return this
    }

    /**
     * @param {String} name - nom de l'objet
     * @returns {Scene} retourn la scene "this" pour le chainage
     * @description l'objet sera déscendu d'un niveau dans l'ordre dans le quel ils sont déssiné
     * @method
     */
    goDown(name){
        let index = this.zorder.indexOf(name)
        if(index  &lt; 1)
            return this
        
            let next = this.zorder[index - 1]
            this.zorder[index - 1] = name
            this.zorder[index] = next
            return this
    }


    /* gestion des Event Mouse/Touch */

    /**
     * @param {Event} e - l'Event
     * @returns {Vector} position de l'Event
     * @description retourn la position d'un Event Mouse/Touch
     * @method
     */
    evtPosition(e){
        let rect = this.canvas.getBoundingClientRect(),
        x = Math.round((e.clientX - rect.left)/(rect.right - rect.left) * this.canvas.width),
        y = Math.round((e.clientY - rect.top)/(rect.bottom - rect.top) * this.canvas.height)
        
        return new Vector(x, y)
    }

    /**
     * @param  {MouseEvent} e - l'Event
     * @returns {Vector} position du curseur de la sourie
     * @description retourn la position d'un Event Mouse
     * @method
     */
    mousePosition(e){
        return this.evtPosition(e)
    }

    /**
     * @param  {TouchEvent} e - l'Event
     * @returns {Vector} position du touché sur l'écran
     * @description retourn la position d'un Event Touch
     * @method
     */
    touchePosition(e){
        return this.evtPosition(e.touches[0])
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Angle.html">Angle</a></li><li><a href="Animation.html">Animation</a></li><li><a href="Animations.html">Animations</a></li><li><a href="AssetsBank.html">AssetsBank</a></li><li><a href="Component.html">Component</a></li><li><a href="EventComponent.html">EventComponent</a></li><li><a href="FileLoader.html">FileLoader</a></li><li><a href="ImgComponent.html">ImgComponent</a></li><li><a href="Scene.html">Scene</a></li><li><a href="Size.html">Size</a></li><li><a href="Source.html">Source</a></li><li><a href="Vector.html">Vector</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Sat Mar 20 2021 11:43:51 GMT+0100 (GMT+01:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
